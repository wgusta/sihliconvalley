<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>User Story Map</title>
<style>
  :root{
    --bg:#fafaf7; --ink:#1f2937; --muted:#6b7280; --line:#e5e7eb; --brand:#0ea5e9;
    --must:#b7f0b1; --should:#fff3b0; --could:#ffd1a8; --wont:#ffc0da; --new:#d1d5db; /* Grau = Default */
    --row-activity:#eaf7ff; /* hellblau */
    --row-task:#f5eaff;     /* helllila */
    --gutter:8px;
    --sticky-shadow:0 8px 20px rgba(0,0,0,.06);
    --radius:14px;
  }
  html,body{height:100%;margin:0}
  body{background:var(--bg);color:var(--ink);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
  header{position:sticky;top:0;z-index:20;backdrop-filter:saturate(1.2) blur(8px);background:rgba(250,250,247,.92);border-bottom:1px solid var(--line)}
  .wrap{width:100%;padding:14px 18px}
  h1{font-size:20px;margin:0 0 6px; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .title-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .proj-input{font:15px/1.3 system-ui; padding:6px 10px; border:1px solid var(--line); border-radius:10px; background:#fff; min-width:220px}
  .sub{color:var(--muted);font-size:13px}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .btn{appearance:none;border:1px solid var(--line);background:#fff;color:var(--ink);padding:8px 12px;border-radius:10px;cursor:pointer;box-shadow:var(--sticky-shadow)}
  .btn[aria-pressed="true"]{background:#1f2937;color:#fff;border-color:#1f2937}
  .legend{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-top:10px}
  .sw{width:14px;height:14px;border-radius:3px;border:1px solid rgba(0,0,0,.08);display:inline-block;margin-right:6px}

  .board{padding:12px}
  .grid{position:relative;margin:18px auto;width:100%;background:#fff;border:1px solid var(--line);border-radius:18px;overflow:auto;box-shadow:var(--sticky-shadow)}

  /* Rollenleiste (separat, eigene Resizer) */
  .roles-wrap{position:sticky;top:0;z-index:5;background:#fff;border-bottom:2px solid var(--line)}
  .roles{display:grid;column-gap:var(--gutter)}
  .roles .cell{background:#f8fafc;min-height:64px;padding:10px;position:relative}
  .roles .head{font-weight:600; user-select:text}
  .roles .label{background:#f8fafc;font-weight:600}
  .roles .resizer{position:absolute;top:0;right:-4px;width:8px;height:100%;cursor:col-resize;background:transparent}
  .roles .resizer:hover{background:rgba(14,165,233,.12)}
  .resizing .roles .resizer{background:rgba(14,165,233,.18)}

  /* sichtbare Abtrennung */
  .divider{height:10px;background:repeating-linear-gradient(90deg,transparent 0 14px,#e5e7eb 14px 15px,transparent 15px 30px)}

  /* Map: eigener Resizer-Kopf + Inhalt */
  .table{display:grid;column-gap:var(--gutter);row-gap:1px}
  .cell{background:#fff;min-height:140px;padding:10px;position:relative;border-top:1px solid var(--line)}
  .rowhead{background:#f8fafc;font-weight:600;white-space:nowrap;border-top:none; user-select:text}
  .map-head .cell{background:#fff;min-height:22px;border-top:none}
  .map-head .resizer{position:absolute;top:0;right:-4px;width:8px;height:100%;cursor:col-resize;background:transparent}
  .map-head .resizer:hover{background:rgba(14,165,233,.12)}
  .resizing .map-head .resizer{background:rgba(14,165,233,.18)}

  /* Reihenfärbung */
  .cell[data-row-type="activity"]:not([data-rc$=":0"]){background:var(--row-activity)}
  .cell[data-row-type="task"]:not([data-rc$=":0"]){background:var(--row-task)}
  /* Stories = weiß */

  /* Stickies */
  .sticky{position:relative;display:inline-block;min-width:120px;max-width:260px;padding:10px 12px 28px;margin:6px;border-radius:var(--radius);
    box-shadow:var(--sticky-shadow);cursor:grab;user-select:none;border:1px solid rgba(0,0,0,.06);transform:rotate(var(--rot,-1deg))}
  .sticky .text{outline:none}
  .bar{position:absolute;right:8px;bottom:6px;display:flex;gap:6px}
  .dot{width:16px;height:16px;border-radius:50%;border:1px solid rgba(0,0,0,.15);cursor:pointer}
  .del{border:none;background:transparent;cursor:pointer;color:#ef4444;font-size:16px}
  .must{background:var(--must)} .should{background:var(--should)} .could{background:var(--could)} .wont{background:var(--wont)} .new{background:var(--new)}

  /* Gruppierung (über Reihen hinweg) */
  .sticky.group-pending{outline:2px dashed #111; outline-offset:2px}
  .sticky.grouped{outline:3px solid var(--grp, #111); outline-offset:2px}
  .group-chip{position:absolute;top:-8px;left:-8px;background:#111;color:#fff;font-size:10px;padding:2px 6px;border-radius:999px;opacity:.85}

  /* Print */
  @media print{
    @page{size:A3 landscape;margin:12mm}
    header{position:static;background:#fff;border:none}
    .toolbar{display:none!important}
    .wrap{padding:0}
    .grid{box-shadow:none;border:1px solid #bbb}
    .sticky{box-shadow:none;border:1px solid rgba(0,0,0,.2)}
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="title-row">
      <h1>User Story Map</h1>
      <input id="projectTitle" class="proj-input" type="text" placeholder="Projekttitel eingeben…" />
    </div>
    <div class="sub">Rollen separat (eigene Breiten). Map mit Zeilenfärbung (Activity/Task/Stories). Karten gruppierbar. Neue Karten sind grau (New).<br>
    <small>Tipp: Rechtsklick auf <b>Rollennamen</b> zum Spalte-löschen, Rechtsklick auf <b>Row-Überschrift</b> zum Row-löschen.</small></div>
    <div class="toolbar">
      <button id="addRole" class="btn">+ Rolle</button>
      <button id="addStoryRow" class="btn">+ Story-Zeile</button>
      <span style="width:10px"></span>
      <button id="groupToggle" class="btn" aria-pressed="false">Gruppieren</button>
      <button id="groupSave" class="btn">Gruppe speichern</button>
      <button id="groupClear" class="btn">Gruppe lösen</button>
      <span style="width:10px"></span>
      <button id="reset" class="btn">Board leeren</button>
      <button id="exportCSV" class="btn">Export CSV</button>
      <label class="btn" style="cursor:pointer">Import CSV<input id="importCSV" type="file" accept=".csv,text/csv" style="display:none"></label>
      <button id="printPDF" class="btn">Drucken / PDF</button>
    </div>
    <div class="legend">
      <span><i class="sw" style="background:var(--must)"></i>Must (Muss)</span>
      <span><i class="sw" style="background:var(--should)"></i>Should (Soll)</span>
      <span><i class="sw" style="background:var(--could)"></i>Could (Kann)</span>
      <span><i class="sw" style="background:var(--wont)"></i>Won't have (Nicht jetzt)</span>
      <span><i class="sw" style="background:var(--new)"></i>New (Klärung, Standard)</span>
    </div>
    <div class="legend" style="margin-top:6px">
      <strong>Zeilen-Legende:</strong>
      <span><i class="sw" style="background:var(--row-activity)"></i>User Activity = Benutzeraktivität/Ziel</span>
      <span><i class="sw" style="background:var(--row-task)"></i>User Task = Aufgabe/Schritt zum Ziel</span>
      <span><i class="sw" style="background:#fff"></i>Stories = Details/Varianten</span>
    </div>
  </div>
</header>

<section id="story" class="board" aria-label="User Story Map">
  <div class="grid" id="storyGrid">
    <div class="roles-wrap">
      <div id="rolesTable" class="roles" role="grid"></div>
    </div>
    <div class="divider"></div>
    <div id="storyHead" class="table map-head" role="grid"></div>
    <div id="storyTable" class="table" role="grid"></div>
  </div>
  <p class="wrap hint">Gruppieren: „Gruppieren" → Karten anklicken (gestrichelt), „Gruppe speichern". Rechtsklick: Gruppe einer Karte entfernen / Row/Spalte löschen.</p>
</section>

<div class="footer">Speichert lokal (localStorage) · CSV Import/Export · PDF-Druck · Keine externen Libraries</div>

<script>
/* ===== Utils & State ===== */
const $ = s => document.querySelector(s);
const uuid = () => Math.random().toString(36).slice(2);
const storageKey = 'bioco-storymap-v2';

const LABEL = { must:'Must (Muss)', should:'Should (Soll)', could:'Could (Kann)', wont:"Won't have (Nicht jetzt)", new:'New (Klärung)' };

/* Gruppierungsfarben (dunkel, unbenutzt) */
const GROUP_COLORS = ['#0f766e','#1e3a8a','#7c3aed','#0f172a','#334155'];
let groupMode = false;
let pendingSet = new Set();
let nextGroupIdx = 0;

/* ===== Persist ===== */
function save(){
  const state = {
    projectTitle: $('#projectTitle').value || '',
    roles: serializeRoles($('#rolesTable')),
    story: serializeTable($('#storyTable')),
    storyCols: getCols($('#storyTable')),
    headCols: getCols($('#storyHead')),
    rolesCols: getCols($('#rolesTable'))
  };
  localStorage.setItem(storageKey, JSON.stringify(state));
  // Dokumenttitel mitschreiben
  document.title = state.projectTitle ? `User Story Map – ${state.projectTitle}` : 'User Story Map';
}
function load(){ const raw=localStorage.getItem(storageKey); return raw?JSON.parse(raw):null; }

/* ===== Project Title ===== */
(function initProjectTitle(){
  const st = load();
  const input = $('#projectTitle');
  if(st?.projectTitle){ input.value = st.projectTitle; document.title = `User Story Map – ${st.projectTitle}`; }
  input.addEventListener('input', save);
})();

/* ===== Stickies ===== */
function makeSticky(text='Neue Notiz', color='new', rotation=2){  // Default = Grau
  const s=document.createElement('div');
  s.className=`sticky ${color}`; s.draggable=true; s.dataset.id=uuid();
  s.style.setProperty('--rot',(Math.random()*rotation*2-rotation).toFixed(2)+'deg');

  const t=document.createElement('div'); t.className='text'; t.contentEditable='true'; t.textContent=text;

  const bar=document.createElement('div'); bar.className='bar';
  ['must','should','could','wont','new'].forEach(c=>{
    const d=document.createElement('button'); d.className='dot'; d.title=LABEL[c];
    d.style.background=getComputedStyle(document.documentElement).getPropertyValue(`--${c}`);
    d.onclick=e=>{e.stopPropagation(); s.className=`sticky ${c}`; save();};
    bar.appendChild(d);
  });
  const del=document.createElement('button'); del.className='del'; del.title='Löschen'; del.innerHTML='&times;';
  del.onclick=()=>{ s.remove(); save(); };
  bar.appendChild(del);

  // Gruppierung: Klick/Contextmenu
  s.addEventListener('click', (e)=>{
    if(!groupMode) return;
    if(pendingSet.has(s)){ pendingSet.delete(s); s.classList.remove('group-pending'); }
    else { pendingSet.add(s); s.classList.add('group-pending'); }
  });
  s.addEventListener('contextmenu', (e)=>{
    e.preventDefault();
    if(s.dataset.groupColor){
      delete s.dataset.groupColor;
      s.classList.remove('grouped');
      s.style.removeProperty('--grp');
      const chip = s.querySelector('.group-chip'); if(chip) chip.remove();
      save();
    }
  });

  s.appendChild(t); s.appendChild(bar);
  s.ondragstart=e=>{ e.dataTransfer.setData('text/plain', s.dataset.id); };
  t.oninput=save;
  return s;
}

/* ===== Gruppen-Controls ===== */
function toggleGroupMode(){
  groupMode = !groupMode;
  $('#groupToggle').setAttribute('aria-pressed', String(groupMode));
  if(!groupMode){ clearPending(); }
}
function clearPending(){
  pendingSet.forEach(s=> s.classList.remove('group-pending'));
  pendingSet.clear();
}
function applyGroup(){
  if(pendingSet.size===0){ alert('Bitte Karten auswählen (Gruppieren → Karte anklicken).'); return; }
  const color = GROUP_COLORS[nextGroupIdx % GROUP_COLORS.length]; nextGroupIdx++;
  pendingSet.forEach(s=>{
    s.dataset.groupColor = color;
    s.style.setProperty('--grp', color);
    s.classList.remove('group-pending');
    s.classList.add('grouped');
    if(!s.querySelector('.group-chip')){
      const chip=document.createElement('div'); chip.className='group-chip'; chip.textContent='Gruppe';
      s.appendChild(chip);
    }
  });
  pendingSet.clear();
  save();
}
function removeGroup(){
  if(pendingSet.size===0){ alert('Bitte Karten auswählen, deren Gruppe gelöst werden soll.'); return; }
  pendingSet.forEach(s=>{
    delete s.dataset.groupColor;
    s.classList.remove('group-pending','grouped');
    s.style.removeProperty('--grp');
    const chip = s.querySelector('.group-chip'); if(chip) chip.remove();
  });
  pendingSet.clear();
  save();
}

/* ===== Grid helpers ===== */
function setCols(el, widths){ el.style.gridTemplateColumns = widths.join(' '); }
function getCols(el){ return getComputedStyle(el).gridTemplateColumns.split(' ').map(s=>s.trim()); }

/* ===== Rollen (separat, eigene Resizer + Löschen per Rechtsklick) ===== */
function buildRoles(el, roles, cols){
  const defaults = [220, ...roles.map(()=>280)].map(v=>`${v}px`);
  setCols(el, cols?.length===roles.length+1 ? cols : defaults);
  el.innerHTML='';
  const label = document.createElement('div'); label.className='cell head label'; label.textContent='Rollen'; el.appendChild(label);
  roles.forEach((name, idx)=>{
    const c=document.createElement('div'); c.className='cell head'; c.contentEditable='true'; c.textContent=name||`Rolle ${idx+1}`;
    c.oninput=save;

    // Rechtsklick: Spalte löschen
    c.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      const colIdx = idx+1; // Map/Head/Story: 1-basiert (ohne linke Spalte)
      if(confirm(`Spalte „${c.textContent.trim()}” wirklich löschen? Alle Karten in dieser Spalte gehen verloren.`)){
        deleteColumn(colIdx);
      }
    });

    const res=document.createElement('div'); res.className='resizer'; res.title='Breite ziehen';
    let startX=0,startW=0,colIndex=idx+1;
    res.onmousedown=(e)=>{
      document.body.classList.add('resizing');
      startX=e.clientX; const current=getCols(el); startW=parseInt(current[colIndex])||280;
      const move=(ev)=>{ const dx=ev.clientX-startX; const w=Math.max(160,startW+dx); current[colIndex]=`${w}px`; setCols(el,current); };
      const up =()=>{ document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); document.body.classList.remove('resizing'); save(); };
      document.addEventListener('mousemove',move); document.addEventListener('mouseup',up);
    };
    c.appendChild(res); el.appendChild(c);
  });
}
function serializeRoles(el){
  const cells = Array.from(el.querySelectorAll('.cell.head')).slice(1);
  return { roles: cells.map(c=>c.textContent.trim()) };
}

/* ===== Map-Kopf (eigene Resizer) ===== */
function buildMapHead(el, colsCount, cols){
  const defaults=[220, ...Array(colsCount).fill(280)].map(v=>`${v}px`);
  setCols(el, cols?.length===colsCount+1 ? cols : defaults);
  el.innerHTML='';
  const left = document.createElement('div'); left.className='cell'; left.textContent=''; el.appendChild(left);
  for(let i=1;i<=colsCount;i++){
    const c=document.createElement('div'); c.className='cell';
    const res=document.createElement('div'); res.className='resizer'; res.title='Breite der Map-Spalte ziehen';
    let startX=0,startW=0,colIndex=i;
    res.onmousedown=(e)=>{
      document.body.classList.add('resizing');
      startX=e.clientX; const current=getCols(el); startW=parseInt(current[colIndex])||280;
      const move=(ev)=>{ const dx=ev.clientX-startX; const w=Math.max(160,startW+dx); current[colIndex]=`${w}px`; setCols(el,current); setCols($('#storyTable'),current); };
      const up =()=>{ document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); document.body.classList.remove('resizing'); save(); };
      document.addEventListener('mousemove',move); document.addEventListener('mouseup',up);
    };
    c.appendChild(res); el.appendChild(c);
  }
}

/* ===== Map-Inhalt (Rows; Löschen per Rechtsklick auf Rowhead) ===== */
function buildStory(el, rows, colsCount, cols){
  const defaults=[220, ...Array(colsCount).fill(280)].map(v=>`${v}px`);
  setCols(el, cols?.length===colsCount+1 ? cols : defaults);
  el.innerHTML='';
  rows.forEach((label, rIndex)=>{
    for(let c=0;c<=colsCount;c++){
      const cell=document.createElement('div'); cell.className='cell'; cell.dataset.rc=`${rIndex}:${c}`;
      if(c===0){
        cell.classList.add('rowhead'); cell.contentEditable='true'; cell.textContent=label; cell.oninput=save;
        // Rechtsklick: Row löschen
        cell.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          const name = cell.textContent.trim() || `Zeile ${rIndex}`;
          if(confirm(`Row „${name}” wirklich löschen? Alle Karten in dieser Row gehen verloren.`)){
            deleteRow(rIndex);
          }
        });
      }else{
        if(rIndex===0) cell.dataset.rowType='activity';
        if(rIndex===1) cell.dataset.rowType='task';
        cell.ondblclick=()=>{ cell.appendChild(makeSticky()); save(); };
        cell.ondragover=e=>{ e.preventDefault(); cell.style.outline='2px dashed #94a3b8'; };
        cell.ondragleave=()=>{ cell.style.outline='none'; };
        cell.ondrop=e=>{ e.preventDefault(); cell.style.outline='none'; const id=e.dataTransfer.getData('text/plain'); const st=document.querySelector(`.sticky[data-id="${id}"]`); if(st) cell.appendChild(st); save(); };
      }
      el.appendChild(cell);
    }
  });
}

/* ===== Snapshot & Rebuild Helpers (für Löschen) ===== */
function snapshotStory(){
  const rows = Array.from($('#storyTable').querySelectorAll('.rowhead')).map(n=>n.textContent.trim());
  const colsCount = getCols($('#storyTable')).length - 1;
  const data = Array.from({length:rows.length},(_,r)=> Array.from({length:colsCount+1},()=>[]));
  // Zellen sammeln (c>=1 sind Inhaltsspalten)
  $('#storyTable').querySelectorAll('.cell').forEach(cell=>{
    const [r,c] = cell.dataset.rc.split(':').map(n=>parseInt(n,10));
    if(c===0) return;
    const cards = Array.from(cell.querySelectorAll('.sticky')).map(st=>{
      const color=['must','should','could','wont','new'].find(k=>st.classList.contains(k))||'new';
      return {
        text: st.querySelector('.text').innerText.replace(/\s+/g,' ').trim(),
        color,
        groupColor: st.dataset.groupColor || ''
      };
    });
    data[r][c] = cards;
  });
  return {rows, colsCount, data};
}

function reinsertStoryData(data, colsCount){
  // data: {rows, colsCount(old), data[r][c]}
  for(let r=0;r<data.rows.length;r++){
    for(let c=1;c<=colsCount;c++){
      const cell = $('#storyTable').querySelector(`.cell[data-rc="${r}:${c}"]`);
      if(!cell) continue;
      const source = data.data[r][c] || [];
      source.forEach(st=>{
        const node = makeSticky(st.text, st.color);
        if(st.groupColor){
          node.dataset.groupColor = st.groupColor;
          node.style.setProperty('--grp', st.groupColor);
          node.classList.add('grouped');
          const chip=document.createElement('div'); chip.className='group-chip'; chip.textContent='Gruppe'; node.appendChild(chip);
        }
        cell.appendChild(node);
      });
    }
  }
}

/* ===== Delete Operations ===== */
function deleteColumn(colIdx /* 1..N */){
  const snap = snapshotStory();
  const roles = serializeRoles($('#rolesTable')).roles;
  if(roles.length < colIdx) return;

  // Rollenliste & Breiten kürzen
  roles.splice(colIdx-1,1);
  const rolesCols = getCols($('#rolesTable')); rolesCols.splice(colIdx,1);
  const headCols  = getCols($('#storyHead'));  headCols.splice(colIdx,1);
  const mapCols   = getCols($('#storyTable')); mapCols.splice(colIdx,1);

  // Daten verschieben: in snap.data, wir verschieben Spalten links zusammen
  const newData = { rows: [...snap.rows], colsCount: snap.colsCount-1, data: Array.from({length:snap.rows.length},()=>[]) };
  for(let r=0;r<snap.rows.length;r++){
    newData.data[r] = Array.from({length:(snap.colsCount)},()=>[]);
    for(let c=1;c<=snap.colsCount;c++){
      if(c === colIdx) continue;
      const newC = c > colIdx ? c-1 : c;
      newData.data[r][newC] = snap.data[r][c] || [];
    }
  }

  // Neu aufbauen
  buildRoles($('#rolesTable'), roles, rolesCols);
  buildMapHead($('#storyHead'), roles.length, headCols);
  buildStory($('#storyTable'), snap.rows, roles.length, mapCols);

  // Reinsert
  reinsertStoryData(newData, roles.length);
  save();
}

function deleteRow(rowIdx /* 0..R-1 */){
  const snap = snapshotStory();
  if(rowIdx<0 || rowIdx>=snap.rows.length) return;

  const newRows = snap.rows.filter((_,i)=>i!==rowIdx);

  // Daten verschieben (Row entfernen)
  const newData = { rows: newRows, colsCount: snap.colsCount, data: Array.from({length:newRows.length},()=>[]) };
  let nr = 0;
  for(let r=0;r<snap.rows.length;r++){
    if(r===rowIdx) continue;
    newData.data[nr] = Array.from({length:(snap.colsCount+1)},()=>[]);
    for(let c=1;c<=snap.colsCount;c++){
      newData.data[nr][c] = snap.data[r][c] || [];
    }
    nr++;
  }

  // Neu aufbauen
  buildStory($('#storyTable'), newRows, snap.colsCount, getCols($('#storyTable')));

  // Reinsert
  reinsertStoryData(newData, snap.colsCount);
  save();
}

/* ===== Serialize/Restore ===== */
function serializeTable(el){
  const out={ cols:getCols(el).join(' '), cells:[], headers:{rows:[]} };
  const cells=el.querySelectorAll('.cell');
  cells.forEach(cell=>{
    const data={ rc:cell.dataset.rc, html:cell.classList.contains('rowhead')?cell.innerHTML:null, stickies:[] };
    cell.querySelectorAll('.sticky').forEach(st=>{
      const color=['must','should','could','wont','new'].find(c=>st.classList.contains(c))||'new';
      data.stickies.push({
        text:st.querySelector('.text').innerText.replace(/\s+/g,' ').trim(),
        color,
        groupColor: st.dataset.groupColor || ''
      });
    });
    out.cells.push(data);
  });
  const rowheads = Array.from(el.querySelectorAll('.rowhead')).map(n=>n.textContent.trim());
  out.headers.rows = rowheads;
  return out;
}
function restoreStory(el,state){
  if(!state) return;
  setCols(el, state.cols.split(' '));
  el.querySelectorAll('.cell').forEach(cell=>{
    const s=state.cells.find(x=>x.rc===cell.dataset.rc); if(!s) return;
    if(cell.classList.contains('rowhead')){ cell.innerHTML=s.html || cell.innerHTML; }
    else {
      s.stickies?.forEach(st=>{
        const node = makeSticky(st.text, st.color);
        if(st.groupColor){
          node.dataset.groupColor = st.groupColor;
          node.style.setProperty('--grp', st.groupColor);
          node.classList.add('grouped');
          const chip=document.createElement('div'); chip.className='group-chip'; chip.textContent='Gruppe'; node.appendChild(chip);
        }
        cell.appendChild(node);
      });
    }
  });
}

/* ===== Defaults ===== */
const defaults = {
  roles: ['Rolle A','Rolle B','Rolle C'],
  storyRows: ['User Activity','User Task','Stories (1)','Stories (2)']
};

/* ===== Build & Restore ===== */
const rolesTable = $('#rolesTable');
const storyHead  = $('#storyHead');
const storyTable = $('#storyTable');

function init(){
  const st = load();

  const roles = st?.roles?.roles || defaults.roles;
  const rolesCols = st?.rolesCols || ['220px','280px','280px','280px'];
  buildRoles(rolesTable, roles, rolesCols);

  const mapCols  = st?.storyCols || ['220px','320px','260px','300px'];
  buildMapHead(storyHead, roles.length, st?.headCols || mapCols);
  buildStory(storyTable, st?.story?.headers?.rows || defaults.storyRows, roles.length, mapCols);

  if(st?.story) restoreStory(storyTable, st.story);
}
init();

/* ===== Controls ===== */
function addRole(){
  const names = Array.from(rolesTable.querySelectorAll('.cell.head')).slice(1).map(n=>n.textContent.trim());
  names.push(`Rolle ${names.length+1}`);
  const newRolesCols = [...getCols(rolesTable), '280px'];
  const newMapCols   = [...getCols(storyTable), '280px']; // Map-Breiten separat
  buildRoles(rolesTable, names, newRolesCols);
  buildMapHead(storyHead, names.length, getCols(storyHead)); // Kopf passt sich an
  buildStory(storyTable, Array.from(storyTable.querySelectorAll('.rowhead')).map(n=>n.textContent.trim()), names.length, newMapCols);
  save();
}
function addStoryRow(){
  const rows = Array.from(storyTable.querySelectorAll('.rowhead')).map(n=>n.textContent.trim());
  const next = rows.filter(r=>/stories/i.test(r)).length+1;
  rows.push(`Stories (${next})`);
  buildStory(storyTable, rows, getCols(storyTable).length-1, getCols(storyTable));
  save();
}

$('#addRole').onclick = addRole;
$('#addStoryRow').onclick = addStoryRow;
$('#reset').onclick=()=>{
  if(!confirm('Wirklich alles leeren?')) return;
  buildRoles(rolesTable, defaults.roles, ['220px','280px','280px','280px']);
  buildMapHead(storyHead, defaults.roles.length, ['220px','320px','260px','300px']);
  buildStory(storyTable, defaults.storyRows, defaults.roles.length, ['220px','320px','260px','300px']);
  save();
};

/* Gruppieren */
$('#groupToggle').onclick = ()=>{ toggleGroupMode(); };
$('#groupSave').onclick   = ()=>{ applyGroup(); };
$('#groupClear').onclick  = ()=>{ removeGroup(); };

/* ===== CSV Export/Import (nur Story Map) ===== */
function toCSV(rows){
  const headers=['Board','Row','Column','Label','Text','GroupColor'];
  const esc=v=>`"${String(v??'').replace(/"/g,'""')}"`;
  return [headers.join(','),...rows.map(r=>headers.map(h=>esc(r[h])).join(','))].join('\n');
}
function tableToRows(name, tableEl){
  const out=[]; const rows=Array.from(tableEl.querySelectorAll('.rowhead')).map(n=>n.textContent.trim());
  const colsCount=getCols(tableEl).length-1;
  for(let r=0;r<rows.length;r++){
    for(let c=1;c<=colsCount;c++){
      const cell=tableEl.querySelector(`.cell[data-rc="${r}:${c}"]`);
      const sticks=cell?Array.from(cell.querySelectorAll('.sticky')):[];
      if(sticks.length){
        sticks.forEach(st=>{
          const color=['must','should','could','wont','new'].find(x=>st.classList.contains(x))||'new';
          out.push({Board:name,Row:rows[r]||'',Column:`Spalte ${c}`,Label:LABEL[color]||color,Text:st.querySelector('.text').innerText.trim(),GroupColor:st.dataset.groupColor||''});
        });
      }else{
        out.push({Board:name,Row:rows[r]||'',Column:`Spalte ${c}`,Label:'',Text:'',GroupColor:''});
      }
    }
  }
  return out;
}
document.getElementById('exportCSV').onclick=()=>{
  const rows=[...tableToRows('User Story Map', storyTable)];
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([toCSV(rows)],{type:'text/csv'}));
  a.download='user-story-map.csv';
  a.click();
};

/* --- CSV Import (nur Story Map) --- */
function parseCSV(text){
  const out = [];
  let i=0, field='', row=[], inQuotes=false;
  const pushField=()=>{ row.push(field); field=''; };
  const pushRow=()=>{ out.push(row); row=[]; };
  while(i<text.length){
    const ch=text[i];
    if(inQuotes){
      if(ch === '"'){
        if(text[i+1] === '"'){ field+='"'; i+=2; continue; }
        inQuotes = false; i++; continue;
      }
      field += ch; i++; continue;
    }else{
      if(ch === '"'){ inQuotes = true; i++; continue; }
      if(ch === ','){ pushField(); i++; continue; }
      if(ch === '\r'){ i++; continue; }
      if(ch === '\n'){ pushField(); pushRow(); i++; continue; }
      field += ch; i++; continue;
    }
  }
  if(field.length || row.length){ pushField(); pushRow(); }
  if(out.length && out[0].length) out[0][0] = out[0][0].replace(/^\uFEFF/, '');
  return out;
}
function storyColumnIndexFromLabel(label){
  const num = /spalte\s*(\d+)/i.exec(label||'');
  if(num) return Math.max(1, parseInt(num[1],10));
  // optional: per Rollenname matchen
  const roleNames = Array.from(document.querySelectorAll('#rolesTable .cell.head')).slice(1).map(n=>n.textContent.trim().toLowerCase());
  if(label){
    const idx = roleNames.indexOf(label.toLowerCase());
    if(idx >= 0) return idx + 1;
  }
  return 1;
}
function ensureStoryHasRows(targetRows){
  const existing = Array.from(document.querySelectorAll('#storyTable .rowhead')).map(n=>n.textContent.trim());
  let changed = false;
  targetRows.forEach(r=>{
    if(r && !existing.includes(r)){
      existing.push(r);
      const colsCount = getCols(document.getElementById('storyTable')).length - 1;
      buildStory(document.getElementById('storyTable'), existing, colsCount, getCols(document.getElementById('storyTable')));
      changed = true;
    }
  });
  if(changed) save();
}
function ensureStoryHasColumns(colIndex){
  const rolesCount = getCols(document.getElementById('storyTable')).length - 1;
  if(colIndex <= rolesCount) return;
  const roleNames = Array.from(document.querySelectorAll('#rolesTable .cell.head')).slice(1).map(n=>n.textContent.trim());
  while(roleNames.length < colIndex){ roleNames.push('Rolle ' + (roleNames.length+1)); }
  const rolesCols = [...getCols(document.getElementById('rolesTable'))];
  const mapCols   = [...getCols(document.getElementById('storyTable'))];
  while(rolesCols.length < colIndex+1) rolesCols.push('280px');
  while(mapCols.length   < colIndex+1) mapCols.push('280px');
  buildRoles(document.getElementById('rolesTable'), roleNames, rolesCols);
  buildMapHead(document.getElementById('storyHead'), roleNames.length, getCols(document.getElementById('storyHead')));
  buildStory(document.getElementById('storyTable'),
             Array.from(document.querySelectorAll('#storyTable .rowhead')).map(n=>n.textContent.trim()),
             roleNames.length, mapCols);
  save();
}

document.getElementById('importCSV').addEventListener('change', async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;
  const text = await file.text();
  const rows = parseCSV(text);
  if(!rows.length){ alert('CSV ist leer.'); e.target.value=''; return; }

  const header = rows[0].map(h=>h.trim().toLowerCase());
  const iBoard = header.indexOf('board');
  const iRow   = header.indexOf('row');
  const iCol   = header.indexOf('column');   // "Spalte N" oder Rollenname
  const iLabel = header.indexOf('label');
  const iText  = header.indexOf('text');
  const iGroup = header.indexOf('groupcolor');

  if(iBoard<0 || iRow<0 || iLabel<0 || iText<0){
    alert('Fehlender Header. Erwartet: Board, Row, Column, Label, Text[, GroupColor]');
    e.target.value=''; return;
  }

  const toInsert = [];
  for(let r=1;r<rows.length;r++){
    const line = rows[r]; if(!line || !line.length) continue;
    const board = (line[iBoard]||'').trim().toLowerCase();
    if(board && !board.includes('story')) continue; // nur User Story Map zulassen
    const rowL  = (line[iRow]||'').trim();
    const colL  = iCol>=0 ? (line[iCol]||'').trim() : '';
    const label = (line[iLabel]||'').trim().toLowerCase();
    const textV = (line[iText]||'').trim();
    const gcol  = iGroup>=0 ? (line[iGroup]||'').trim() : '';
    if(!textV) continue;

    const colIndex = storyColumnIndexFromLabel(colL);
    toInsert.push({rowL, colIndex, label, textV, gcol});
  }

  // Struktur sicherstellen
  const neededRows = Array.from(new Set(toInsert.map(x=>x.rowL))).filter(Boolean);
  if(neededRows.length) ensureStoryHasRows(neededRows);
  const maxCol = Math.max(1, ...toInsert.map(x=>x.colIndex));
  if(maxCol > (getCols(document.getElementById('storyTable')).length-1)){
    ensureStoryHasColumns(maxCol);
  }

  // Einfügen
  toInsert.forEach(({rowL,colIndex,label,textV,gcol})=>{
    const tableEl = document.getElementById('storyTable');
    let rowIndex = -1;
    const rowheads = Array.from(tableEl.querySelectorAll('.rowhead'));
    for(let i=0;i<rowheads.length;i++){
      if(rowheads[i].textContent.trim() === rowL){ rowIndex = i; break; }
    }
    if(rowIndex === -1){
      const rowsNow = rowheads.map(n=>n.textContent.trim());
      rowsNow.push(rowL || ('Zeile ' + (rowsNow.length+1)));
      buildStory(tableEl, rowsNow, getCols(tableEl).length-1, getCols(tableEl));
      rowIndex = rowsNow.length-1;
    }
    const cell = tableEl.querySelector(`.cell[data-rc="${rowIndex}:${colIndex}"]`);
    if(!cell){ console.warn('Zielzelle nicht gefunden:', rowL, colIndex); return; }

    let cls='new';
    if(label.includes('muss')||label==='must') cls='must';
    else if(label.includes('soll')||label==='should') cls='should';
    else if(label.includes('kann')||label==='could') cls='could';
    else if(label.includes('nicht jetzt')||label.includes("won't")||label.includes("won't")) cls='wont';
    else if(label.includes('neu')||label.includes('klär')||label==='new') cls='new';

    const node = makeSticky(textV, cls);
    if(gcol){
      node.dataset.groupColor=gcol; node.style.setProperty('--grp', gcol); node.classList.add('grouped');
      const chip=document.createElement('div'); chip.className='group-chip'; chip.textContent='Gruppe'; node.appendChild(chip);
    }
    cell.appendChild(node);
  });

  save();
  alert('CSV importiert (User Story Map).');
  e.target.value='';
});

/* Print */
document.getElementById('printPDF').onclick=()=>window.print();
</script>
</body>
</html>

